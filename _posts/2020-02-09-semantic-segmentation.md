---
layout: post
title: 图像语义分割
categories:
  - 机器学习
tags:
  - 图像分割
  - 语义分割
date: 2020-02-09 18:29:35
giscus_comments: true
---

图像分割，或者叫语义图像分割，通过给图像的每一个像素分配一个它所属的类别标签。通过这种分割可以把图像中语义抽象表示出来，也是计算机视觉中一个非常重要的方向，有着非常众多重要应用场景，包括自动驾驶中的场景分割，医学影像中的病灶区域分割等。

<div class="row">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.liquid loading="eager" path="assets/img/2020-02-09-semantic-segmentation/abs.png" title="abs" class="img-fluid rounded z-depth-1" %}
    </div>
</div>

<!-- more -->

# 传统方法

称传统方法是为了区别于基于深度学习的方法，主要由很多手工设计的显式特征提取算法构成算法的主要部分。

## 阈值方法

在深度学习广泛占据视角之前，经常通过手工设计的特征检测方法对图像进行处理，包括通过阈值分割，把颜色深的文字和颜色浅的背景分割开来，基于这种思想，又发展出多阈值分割，动态阈值分割，将智能遗传算法应用在局部阈值的选取上等方法。但是总体而言这种基于阈值分割的方法计算量低，对噪声敏感。

## 局部生长

基于同一个目标物有相似的图像特征，基于选定种子像素点开始向周围生长的方法，不断将和像素相邻的相似区域并入生长区域，并将新添加的像素点作为新的种子点继续向外合并的方法称为区域生长算法。这种方法的关键为：

1. 选择一组有代表性的种子像素
2. 用于判断相邻像素是否可以合并的准则
3. 算法停止生长的边界条件

## 区域分裂合并

和局部生长算法相对应，是从整幅图像出发，通过不断地分裂得到各个子区域，然后再从子区域集合中选出子集得到需要分割的前景目标。局部生长判断是否可以合并，区域分裂判断是否可以分裂，在实际应用中也常常和局部生长结合使用，但是通常需要考虑目标场景的先验知识，例如光照条件、目标大小等。

## 分水岭算法

分水岭算法 (watersheld) 和名字相似，可以想象成往沟壑纵横的山岭地形中倒水，低洼地带会积聚水，高耸地带不会被水淹没。针对图像场景，通常用图像中像素值大小来代表地形高低，水从每个局部最低点涌出，都一直涨到刚好快要溢出大坝的高度，这样就可以将图像分割成很多的区域。比如针对细胞照片数据就可以用过这种算法把细胞从背景中分离出来，方便后续对于细胞的统计。

## 基于边缘的检测

通常在图像的目标物之间都会有明显的边缘差异，人们通过这种差异来区分一个物体和另外一个物体，例如区分图像中的黑色的马路和绿色的草地有明显的边缘。人们设计出多种边缘检测算子包括一阶梯度，Roberts算子，Sobel算子，Prewit算子，Kirsh算子，Lapalacian算子等，用于不同场景下的边缘检测。但是边缘检测常常不能产生连续的边缘，在此基础上又有了各种动态边缘检测的方法保证获取更加光滑准确的边缘。

## 主动轮廓模型

主动轮廓模型有统一开放的描述方式，可以想象给定一个初始的闭合曲线，通过设计的内部能量和外部能量计算函数，想象该曲线会同时受到向内和向外的力，力的大小和方向取决于图像数据的特征，曲线在这两种力的作用下最终会收敛到一个合适的轮廓。这种动态逼近的方法可以保证曲线是闭合光滑的。

Snake模型是一种非常经典的活动模型，曲线受到的内力用于约束曲线形状，外力则用于牵拉模型到特征轮廓位置，这两种力最终引导曲线能很好地贴合图像的视觉分割边界。

# 深度方法

深度卷积神经网络有着非常高的特征提取能力，因此子能够为图像分割提供极为丰富的特征，有时候也和传统方法结合以获得更好的目标特征建模能力。例如 VGGNet 和 ResNet 都是性能非常卓越的特征提取网络，也广泛用于图像分类，目标跟踪，图像语义分割等应用实例的基础特征提取网络中。常见的做法为，保持特征提取基础网络不变，替换模型最后几层的网络结构为特定任务的网络结构，然后通过任务指定的优化目标对整个网络进行重新训练。

现在常见的两种语义分割的任务包括：

- **类别预测**：估计出每一个像素所属的类别
- **目标分割**：估计出每个像素所属的目标，用于区分场景中不同的个体

## 全卷积网络

<div class="row">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.liquid loading="eager" path="assets/img/2020-02-09-semantic-segmentation/FCN.png" title="FCN" class="img-fluid rounded z-depth-1" %}
    </div>
</div>
全卷积的网络，通过不断的卷积采样，获得高维的特征，然后通过上采样（线性插值，反卷积等）将分辨率低的特征图映射成和输入图像大小相同的分割图像，再通过损失函数对网络中的参数进行优化，在同一个输出特征图上同时计算分割和分类的误差。

<div class="row">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.liquid loading="eager" path="assets/img/2020-02-09-semantic-segmentation/UNet.jpg" title="UNet" class="img-fluid rounded z-depth-1" %}
    </div>
</div>
U-Net 通过卷积和下采样获得更高级别的语义信息，然后通过上采样的方式得到和输入图像大小一致的类别分割图。为了保持低级的信息也能继续保持在最终的输出结果中，原图进行下采样时也会将对应的特征图和上采样后得到的对应相同大小的特征图进行拼接，使得最终的输出结果有更加精细的分割效果。

## 基于区域选择

也就是基于 RPN（Region Proposal Network）的思想，来自于目标检测任务的解决思路，通过低级的特征，例如颜色空间的相似矩阵等，算法根据这些结果预先提出 2000 个候选框，然后把每个框内的内容输入分类网络，最终只留下几个分类模型最确定的框来表示目标的位置和类别，但是这种做法有非常明显的性能劣势。Fast R-CNN 的提出就是为了改进这其中非常耗时的超多候选框判断问题，直接通过特征图生成图像中各个网格区域的特征，然后直接得到对应的分类置信度对这些网格进行重新组合，得到一个修正的包围框表示这个目标的位置。在此基础上又有了改进方案 Faster R-CNN，用 RPN 网络进行候选区域的提取。

<div class="row">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.liquid loading="eager" path="assets/img/2020-02-09-semantic-segmentation/RPN.jpg" title="RPN" class="img-fluid rounded z-depth-1" %}
    </div>
</div>
通过以每个特征图的像素点为中心生成这些密密麻麻的候选网格，用一个二分类器判断每个网格是否有用，从而能够降低整体的计算开销，快速得到各个目标的位置和类别。

Mask R-CNN 分割方法也就是建立在这些候选框提出到分类的工作基础上，用的是多分枝的结构，同时输出物体的类别、包围框和蒙版，用的是二值判断确定各个像素是否属于某个物体类别。主要的贡献有：

- 在 Faster R-CNN 的基础上，对于 Faster-RCNN 提出的每个候选包围框都用 FCN 进行语义分割，同时实现分割，定位，分类三个任务
- 引入 ROI Align 代替基于池化的粗超网格划分方法，提高了分类细粒度，可以极大提高目标蒙版的精度
- 用多个分支，Mask 分支只做语义分割，类别分支制作类别预测，和原始的 FCN 不同

针对 ROI Align，因为之前的 Faster R-CNN 方法是给特征上每一个点都提出 9 个大小形状不同的 ROI 这些不同的 ROI 需要经过 ROI Pooling 才能转化成大小维度一致的输入到下一层网络，而在分割任务中这么做就会损失图像原有的细节特征（因为被形变，长宽比都不对了），所以 ROI Align 通过双线性插值找到每个块对应的特征。

## 特征金字塔

<div class="row">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.liquid loading="eager" path="assets/img/2020-02-09-semantic-segmentation/PSN.png" title="PSN" class="img-fluid rounded z-depth-1" %}
    </div>
</div>
通过卷积神经网络获得输入图像（a）的特征图（b），然后通过不同大小的池化操作获得多个分辨率的特征图（c）然后再通过上采样（放大）的操作将这些特征图组合在一起经过卷积神经网络之后获得最终的输出（d）。

## 条件随机场

条件随机场（CRF，Conditional Random Field）是一种特殊的马尔可夫随机场，马尔可夫随机场（MRF，Marcov Random Field）是一种基于统计的图像分割算法，马尔可夫模型是指一组事件的集合，集合中每个事件的发生仅仅由前一个事件的发生决定，和更早之前发生的事件无关。马尔可夫随机场就代表，任何区域都只和它邻近的区域有关，图像中每个像素（或者更大块的特征）的集合就组成一个马尔可夫随机场。CRF 则是一种在给定一组输入随机变量 $$X$$ 有另一组随机变量 $$Y$$ 的输出，现实中我们常常假设 $$X$$ 和 $$Y$$ 有相同的结构
$$X=(x_{1}, x_{2}, \dots, x_{n}),\quad Y=(y_{1}, y_{2}, \dots, y_{n})$$
图像分割就是要找出每个像素点对应的类别，即给定 $$x$$ 时求概率最大的 $$y$$：
\begin{equation}
\hat{y}^{\text{MAP}} = \text{argmax}\_{y\in Y}P(y|x)
\end{equation}

条件随机场符合吉布斯分布[^1]:
\begin{equation}
P(\mathbf{X}=x|\mathbf{I})=\frac{1}{Z(\mathbf{I})}\exp(-E(x|\mathbf{I}))
\end{equation}
其中 $$E(x\vert \mathbf{I})$$ 表示能量函数
\begin{equation}
E(x)=\sum\_{i}\theta\_{u}(x\_{i}) + \sum\_{i\le j}\theta\_{p}(x\_{i},x\_{j})
\end{equation}
其中一元势函数 $$\sum_{i}\theta(x_{i})$$ 可以是 FCN 的输出，而二元势函数为：
\begin{equation}
\theta\_{ij}(x\_{i}, y\_{j}) = u(x\_{i}, x\_{j})\sum^{m}\_{m=1}\omega^{(m)}k\_{G}^{(m)}(\mathbf{f}\_{i}, \mathbf{f}\_{j})
\end{equation}
二元势函数描述像素之间的关系，鼓励相似像素分配相同的标签，相差大的像素分配不同的标签，距离的定义由实际相对距离和颜色等差别决定，保证图片尽量在边界处分割，全连接条件随机场值是指每个像素和所有其他像素的区别。

## 评价指标

### Pixel Accuracy

分类正确的像素点数和所有的像素点数的比例
\begin{equation}
PA = \frac{\sum^{k}\_{i=0}p\_{ii}}{\sum^{k}\_{i=0}\sum^{k}\_{j=0}p\_{ij}}
\end{equation}

### Mean Pixel Accuracy (MPA)

计算每一类分类正确的像素点数和该类的所有像素点数的比例然后求平均
\begin{equation}
MPA=\frac{1}{k}\sum^{k}\_{i=0}\frac{p\_{ii}}{\sum^{k}\_{j=0}p\_{ij}}
\end{equation}

### Mean Intersection over Union (MIoU)

计算每一类的IoU然后求平均。一类的IoU计算方式如下，例如i=1，$$p_{11}$$ 表示true positives，即本属于1类且预测也为1类，$$\sum^{k}_{k=0}p_{1j}$$ 表示本属于1类却预测为其他类的像素点数（注意，这里包含了 $$p_{11}$$）。$$\sum^{k}_{j=0}p_{j1}$$ 表示本属于其他类却预测为1类的像素点数（注意，这里也包含了 $$p_{11}$$ ），在分母处 $$p_{11}$$ 计算了两次所以要减去一个 $$p_{11}$$
\begin{equation}
MIoU = \frac{1}{k+1}\sum^{k}\_{i=0}\frac{p\_{ii}}{\sum^{k}\_{j=0}p\_{ij}+\sum^{k}\_{i=0}p\_{ji}-p\_{ii}}
\end{equation}

### Frequency Weighted Intersection over Union (FWIoU)

可以理解为根据每一类出现的频率对各个类的IoU进行加权求和
\begin{equation}
FWIoU=\frac{1}{\sum^{k}\_{i=0}\sum^{k}\_{j=0}p\_{ij}}\sum^{k}\_{i=0}\frac{p\_{ii}\sum^{k}\_{j=0}p\_{ij}}{\sum^{k}\_{j=0}p\_{ij}+\sum^{k}\_{j=0}p\_{ij}-p\_{ii}}
\end{equation}

## 数据集

### MS COCO

MS于2014年发布的Microsoft COCO数据集，已成为图像字幕的标准测试平台。

原来的数据集有20G左右的图片和500M左右的标签文件。标签文件标记了每个segmentation+bounding box（即分割物+分割物的边界）的精确坐标，其精度均为小数点后两位。例如，一个目标分割物的标签示意如下：

```json
{
  "segmentation": [
    [
      392.87, 275.77, 402.24, 284.2, 382.54, 342.36, 375.99, 356.43, 372.23, 357.37, 372.23, 397.7, 383.48, 419.27, 407.87, 439.91, 427.57, 389.25,
      447.26, 346.11, 447.26, 328.29, 468.84, 290.77, 472.59, 266.38
    ],
    [429.44, 465.23, 453.83, 473.67, 636.73, 474.61, 636.73, 392.07, 571.07, 364.88, 546.69, 363.0]
  ],
  "area": 28458.996150000003,
  "iscrowd": 0,
  "image_id": 503837,
  "bbox": [372.23, 266.38, 264.5, 208.23],
  "category_id": 4,
  "id": 151109
}
```

数据集以场景理解为目标，主要从复杂的日常场景中截取，图像中的目标通过精确的segmentation（分割）进行位置的标定。

### ADE20K 数据集

ADE20K 是用来做 scene parsing 的一个非常大的数据集合，包含 150 中物体类型，由 MIT CSAIL 研究组维护。数据集主页在 http://groups.csail.mit.edu/vision/datasets/ADE20K/

---

[^1]: [吉布斯采样-维基](https://zh.wikipedia.org/zh-hans/%E5%90%89%E5%B8%83%E6%96%AF%E9%87%87%E6%A0%B7)
