<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Particle Filters | Curiousity Hub </title> <meta name="author" content="Zenan Huang"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="causal-learning, causal-discovery, transfer-learning, LLMs, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/favicon-32x32-next-my.png?b29ea1d332f6bc3c021e15d78d266303"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://lccurious.github.io/blog/2018/Particle-Filters/"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?0afe9f0ae161375728f7bcc5eb5b4ab4"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Curiousity Hub </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">submenus </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/cv/">cv</a> </div> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Particle Filters</h1> <p class="post-meta"> August 29, 2018 </p> <p class="post-tags"> <a href="/blog/2018"> <i class="fa-solid fa-calendar fa-sm"></i> 2018 </a>   ·   <a href="/blog/tag/%E6%BB%A4%E6%B3%A2"> <i class="fa-solid fa-hashtag fa-sm"></i> 滤波</a>     ·   <a href="/blog/category/%E6%8A%A5%E5%91%8A"> <i class="fa-solid fa-tag fa-sm"></i> 报告</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> <p>Particle Filters，从1993年提出来就作为一种应用很广的最优化估计算法，用于解决非线性非高斯分布的状态空间问题求解，通过在线的数值估计的方式解决问题。现在也应用在像计算机视觉，计量经济学，机器人学和导航等各种各样的场景中。<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>并且随着改进方案的不断提出，Particle Filters也可以应用在更加高维，更加复杂的场景中。<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></p> <h2 id="背景">背景</h2> <p>Particle Filters可以作为解决两个机器人领域全局定位和kidnapped robot的问题，用于帮助机器人在不确定状况下求解自身的全局位置的问题。卡尔曼滤波（Kalman filter）假设目标为线性模型，噪声为高斯分布，返回一个假设值。但是当目标对象运动非常快速，或者不太容易预测（比如大风天随风飘动的树叶）那就会失效，但是Particle Filters可以返回很多的假设（每个Particle代表一个假设）目标的状态可以是位置可以是模型的形状等。</p> <p>粒子滤波可以在跟踪问题上表现出较好的效果，在实际情况中，我们需要应用的场景都比较复杂，简单地总结一下应用场景的特征就是：</p> <ul> <li>多模型：我们需要跟踪的目标不止一个</li> <li>震荡：有些目标可能会被遮挡</li> <li>非线性行为：飞行器会受到风的影响，球会收到各种摩擦力的影响，人的行走也会被人群影响</li> <li>非线性的测量：像雷达测量的结果，转换到3维坐标是要开平方根的</li> <li>非高斯噪声：当目标穿过背景的时候，有时候计算机视觉会错误识别背景和前景</li> <li>连续性：目标的位置和目标的速度等可以做到在时间上平滑</li> <li>多变量：我们要跟踪多个指数，包括位置，速度，变换速率等</li> <li>未知过程模型：甚至不知道系统内部的工作规律，比如某些动物的运动</li> </ul> <h2 id="概念">概念</h2> <p>粒子滤波（Particle Filters）是一种常见的函数最优化的算法，它的搜索空间是通过粒子（采样）去搜索，然后验证粒子所代表的解，根据解的优劣赋予不同的权重，权重越高的采样会被增加，验证后结果较差的采样会被减少。然后所有剩下的粒子会被带入到另一轮的重新采样中去，不断循环直到找到最优解。</p> <h2 id="蒙特卡洛逼近">蒙特卡洛逼近</h2> <p>通过数值方法计算积分最简单的方法是通过求小矩边梯形的面积再累加，但是如果函数的维度太高，变量的数量太多的情况下，简单的方法就难以适用了，而蒙特卡洛方法可以从概率学的角度出发近似地计算这些积分。</p> <p>对于形式如 \(I=\int^{b}_{a}h(x)g(x)dx\) 的积分形式，如果能够转换用密度函表示的形式就可以通过采样函数进行模拟。也就是对于随机变量\(X\)的函数\(f(x)\)，其期望值可以通过下面的公式计算。</p> \[E[f(x)] = \int_{p(x)}p(x)f(x)dx\] <p>其中，\(p(x)\)为变量\(X\)的密度函数，在定义域上的积分为1。</p> <p>这种平均值我们可以根据大数定理知道，对于一个已知分布的随机序列，当取样数趋于无穷时，其均值趋向于期望。所以上面的公式可以再写成如下形式：</p> \[E[f(X)]=\int f(x)p(x)dx \approx \frac{1}{S}\sum^{S}_{n=1}f(x_s)\] <p>其中\(x_s\sim p(X)\)，这是一个很重要的条件，即生成的随机数要符合密度函数为\(p(X)\)的分布，这样计算得到的平均值才是积分的近似值。</p> <h2 id="粒子滤波跟踪">粒子滤波跟踪</h2> <p>粒子滤波跟踪通常可以简单地分为以下几个步骤：</p> <ol> <li>随机生成一堆粒子：每个粒子可以包括位置，指向，或者任何你需要的状态信息，每个粒子都有它的权重，这个权重表示了它和真实系统状态的吻合程度。刚开始所有的粒子的权重都是相同的。</li> <li>预测粒子的下一个阶段：通过对于真实系统行为的预测，移动粒子</li> <li>更新：基于测量结果更新粒子的权重，接近测量结果的粒子权重将被增加</li> <li>重采样：丢弃那些不相关的粒子，复制那些更加可信的粒子</li> <li>计算估计：可选操作，计算粒子的加权平均和方差得到状态估计</li> </ol> <p>基于粒子滤波的目标跟踪是一种生成式跟踪方法，所以有初始化的阶段。对于一帧图像，首先人为给定它的初始化，在特定的区域提出特征。</p> \[k( r ) = \begin{cases}1-r^2, r &lt; 1 \\ 0, otherwise \end{cases}\] <p>其中\(r\)是区域到中心的距离，</p> <h3 id="初始化">初始化</h3> <p>如果我们是被动地跟踪目标（我们不知道它的运动方式，也就是没有运动控制的输入信息），就还需要将各个维度的速度也加入到状态空间中去，维度越高就需要指数增长的粒子数量来进行跟踪。<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>针对一个机器人追踪问题，我们可以定义粒子模型</p> \[s=\{x, y, v_x, v_y, H_x, H_y, a\}\] <h3 id="重采样">重采样</h3> <p>在重采样的过程中，可能性低的粒子会被舍弃，可能性高的粒子会被复制，但是也不是原原本本的复制，这些原本粒子的副本会在预测阶段再增加一些噪声。这样在新得到的点集中，粒子中的绝大多数可以准确地表示出概率分布。</p> <p>重采样有很多种对应的算法，最简单的一种是随机采样算法，随机采样是根据权重分配被采样到的的概率，权重越大的粒子就越容易被采到。</p> <p>重采样的频率也是通过一种规则确定的，因为如果没有收到新的观测值，也就不能从重采样过程中获得新的信息。所以可以根据一个影响因子\(N\)来进行估计是否要进行重采样，这个影响因子大致衡量了那些对于概率分布有贡献的粒子的数量。</p> \[\hat{N}_{eff} = \frac{1}{\sum w^2}\] <p>一个比较有效的点大概是在\(N/2\)这个值左右，但是也要依据情况而定，甚至还会出现\(\hat{N}_{eff}=N\)的情况，这是因为所有的点都模式坍塌到一个点去了（每个点都有相同的权重），这不是一个好的现象，有时可以通过增加粒子数量来避免，但是如果经常出现，你就需要调整你自己的算法了。</p> <p>在开始的几轮，滤波器会带来很多重复的粒子，这是因为传感器的建模方式是基于高斯的，而且只有很小的标准差，这种较小的噪声对于卡尔曼滤波器而言是一件好事，但是对于粒子滤波器会让它表现地更差。这是因为在重采样的过程中，离观察结果稍微远一点的粒子就会被抛弃了，导致留下的粒子同质化比较严重。</p> <p>同时，粒子滤波的效果也与初始化设置的种子有很大的关系，有些初始化所用的种子会导致在后来重采样的过程中不收敛，甚至与我们的预期远远不相符合。因此，也要尽量生成一些粒子在初始状态的周围（想办法去估计这些粒子的状态信息），不过也没有必要把点估计的太精准，因为太过单一准确的初始估计也会使滤波器难以把握系统中的非线性。并且对于这种非线性的问题，我们还是要避免分布中的方差太小的问题。</p> <h3 id="重要性采样">重要性采样</h3> <p>我们需要从一些分布中获得机器人的位置和某些信息，从这些分布中得到粒子的采样，并且通过蒙特卡洛采样获得对应的积分。</p> <p>很多问题是没法获得对应的分布的，比如你要追踪一个目标，但是根本就不知道它将往何处去，预测阶段也无法实现。重要性采样的用处就在于，通过一个不同但已知的分布来获得对应未知分布的性质。</p> <p>思路也是很简单的，我们从已知的分布中抽取样本，然后用我们感兴趣的分布来确定样本的权重，然后就可以通过这种方式可以得到这些加权的样本均值和方差这些代表分布的特性。</p> <p>假设我们有一个机器人在过道中，根据上一次的估计结果，我们知道，在下一时刻，它将可能保持哪种速度，将会出现在什么位置，这些是可以预测的。但是，如果它掉到坑里了，又或者被人撞了一下，那原来的根据预计的速度和位置估计的下一时刻的状态也就不准确了。所以我们还是要根据测量结果来给粒子赋予权重，这些权重是根据真实的分布得出来的。</p> <p>\(\pi(x)\)：是我们感兴趣的分布，但是是未知的 \(q(x)\)：这是一个我们已经知道的分布，是测量结果的分布</p> <p>我们可以对下面的积分进行改写：</p> \[\mathbb{E}[f(x)]=\int f(x)\pi(x)dx\] <p>但是我们不知道\(\pi(x)\)的分布，带入一项：</p> \[\mathbb{E}[f(x)]=\int f(x)\pi(x)\cdot\frac{q(x)}{q(x)}dx\] <p>改写这条公式的形式不影响结果：</p> \[\mathbb{E}[f(x)]=\int f(x)q(x)\cdot\frac{\pi(x)}{q(x)}dx\] <p>这样我们就可以通过已知的分布用蒙特卡洛积分的办法来解决问题，也就生息的是\(\pi(x)/q(x)\)，这个比例也就是我们在测量阶段所说的的权重。因此，积分改写成：</p> \[\mathbb{E}[f(x)] = \sum^{N}_{i=1} f(x^{i}) w(x^{i})\] <p>更加通俗地可以表示成计算粒子的加权平均值：</p> \[\mu = \sum^{N}_{i=1} x^{i} w^{i}\] <p>所以简单地解释一下下面的权重的更新代码：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">particles</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">landmarks</span><span class="p">):</span>
    <span class="n">weights</span><span class="p">.</span><span class="nf">fill</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span>
    <span class="c1"># 遍历状态空间，将各个要素的分布都叠加在一起
</span>    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">landmark</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">landmarks</span><span class="p">):</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">norm</span><span class="p">(</span><span class="n">particles</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">landmark</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># 这里的dist是分布的均值，R表示分布的区间
</span>        <span class="n">weights</span> <span class="o">*=</span> <span class="n">scipy</span><span class="p">.</span><span class="n">stats</span><span class="p">.</span><span class="nf">norm</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">R</span><span class="p">).</span><span class="nf">pdf</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">weights</span> <span class="o">+=</span> <span class="mf">1.e-300</span> <span class="c1"># avoid round-off to zero
</span>    <span class="n">weights</span> <span class="o">/=</span> <span class="nf">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="c1"># normalize
</span></code></pre></div></div> <h4 id="多项式重采样">多项式重采样</h4> <p>得到各个粒子的权重集合之后，需要根据这些权重进行采样，我们期望权重越大则该粒子更容易被采集到。通过对概率分布函数进行积分，得到累计概率函数，针对采样问题就是对概率分布数列进行累加，生成均匀分布的随机数，通过二分查找确定这个随机数所在的区间，这个区间即对应一个粒子，这种采样方式的复杂度为\(O(N\log N)\)。</p> <h4 id="残差重采样">残差重采样</h4> <p>残差重采样可以将复杂度降低到\(O(N)\)，通过残差重采样实现高效的采样过程。残差重采样不仅可以提高运行效率还能保证权重较大的粒子至少能被采样到一次。</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">residual_resample</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
    <span class="n">indexes</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="sh">'</span><span class="s">i</span><span class="sh">'</span><span class="p">)</span>
    <span class="c1"># take int (N*w) copies of each weight
</span>    <span class="n">num_copies</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="nf">asarray</span><span class="p">(</span><span class="n">weights</span><span class="p">)).</span><span class="nf">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="c1"># 插一句题外话使用小循环比使用小切片要更快
</span>        <span class="c1"># indexes[k:k+num_copies[i]] = i (小切片索引真的很慢)
</span>        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">num_copies</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
            <span class="n">indexes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># use multinomial resample on the residual to fill up the rest
</span>    <span class="n">residual</span> <span class="o">=</span> <span class="n">w</span> <span class="o">-</span> <span class="n">num_copies</span>   <span class="c1"># get fractional part
</span>    <span class="n">residual</span> <span class="o">/=</span> <span class="nf">sum</span><span class="p">(</span><span class="n">residual</span><span class="p">)</span>    <span class="c1"># normalize
</span>    <span class="n">cumulative_sum</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">cumsm</span><span class="p">(</span><span class="n">residual</span><span class="p">)</span>
    <span class="n">cumulative_sum</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span> <span class="c1">#ensure sum is exactly one
</span>    <span class="n">indexes</span><span class="p">[</span><span class="n">k</span><span class="p">:</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">searchsorted</span><span class="p">(</span><span class="n">cumulative_sum</span><span class="p">,</span> <span class="nf">random</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="n">k</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">indexes</span>
</code></pre></div></div> <h4 id="分层采样">分层采样</h4> <p>分层采样方式会先将累计密度分布分成\(N\)个相同长度的段，然后从每个段中随机选取一个粒子。这种采样方式保证了每个样本之间有\(0\sim \frac{2}{N}\)的间隔。</p> <h4 id="系统性重采样">系统性重采样</h4> <p>前面的分层采样把累计分布函数分成等长的段，在每个段中随机采样，而这里是随机选择一个偏移量，每个段中都采集这个偏移位置的粒子。</p> <h4 id="重采样测试">重采样测试</h4> <p>在测试过程中，多项式采样的表现比较差，很多权重较大的粒子都被忽略了，而权重小的粒子却被采样了多次。而残差重采样确实比较好的达到了它的目的，但是还是有很多比较合适的粒子没有被采集到。分层采样和系统性采样的表现都相对比较好，</p> <h2 id="总结">总结</h2> <p>粒子滤波（Particle Filters）有时候就像是一种集成方法，这和卡尔曼滤波等有比较不同的区别，卡尔曼滤波是一个优化的针对线性、高斯噪声的模型，它非常高效但是一旦情况变得复杂和不可预测就会失效。而粒子滤波可以在这种复杂的情形下做倒比较好的效果，前提是粒子的数量足够多的情况下。重要性采样让我们可以在不知道目标分布的情况下获得比较好的估计，蒙特卡洛方法让我们对可以求解那些可以滤波器中要求的积分。</p> <p>但是粒子滤波的能力是通过比较高额的计算开销达成的，大量的粒子需要很高的内存开销，同时还需要考虑粒子的退化等问题。</p> <hr> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:1" role="doc-endnote"> <p>Doucet, A., &amp; Johansen, A. M. (2011). A tutorial on particle filtering and smoothing: fifteen years later. In Handbook of Nonlinear Filtering (eds, 12. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:2" role="doc-endnote"> <p>Thrun, S. (2002). Particle filters in robotics. Eighteenth Conference on Uncertainty in Artificial Intelligence (Vol.volume 19, pp.511-518). Morgan Kaufmann Publishers Inc. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:3" role="doc-endnote"> <p>Roger R Labbe Jr Kalman and Bayesian Filters in Python May 8, 2018 <a href="#fnref:3" class="reversefootnote" role="doc-backlink">↩</a></p> </li> </ol> </div> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2018/Monte-Carlo-Tree/">蒙特卡洛搜索树</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2018/A-3D-Modeller-zh/">一个3D模型（译）</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2021/distill/">a distill-style blog post</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2019/Thin-Plate-Spline/">Thin Plate Spline</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2019/Simple-Socket-Server/">简单的 Socket 服务</a> </li> <div id="giscus_thread" style="max-width: 800px; margin: 0 auto;"> <script>let giscusTheme=localStorage.getItem("theme"),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"lccurious/lccurious.github.io","data-repo-id":"","data-category":"Comments","data-category-id":"","data-mapping":"title","data-strict":"1","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":giscusTheme,"data-lang":"en",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([t,e])=>giscusScript.setAttribute(t,e)),document.getElementById("giscus_thread").appendChild(giscusScript);</script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Zenan Huang. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2930004b8d7fcd0a8e00fdcfc8fc9f24"></script> <script defer src="/assets/js/common.js?da39b660470d1ba6e6b8bf5f37070b6e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>